<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>简易俄罗斯方块</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
        }
        
        .game-board {
            border: 2px solid #333;
            background-color: #fff;
        }
        
        .info-panel {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .next-piece {
            width: 120px;
            height: 120px;
            border: 2px solid #333;
            background-color: #fff;
            margin-bottom: 20px;
        }
        
        .score-panel {
            margin-bottom: 20px;
        }
        
        .score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .level {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #4338ca;
        }
        
        .controls-info {
            margin-top: 20px;
            font-size: 14px;
            color: #555;
        }
        
        .controls-info p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameBoard" class="game-board" width="240" height="400"></canvas>
        
        <div class="info-panel">
            <div>
                <h2>下一个方块</h2>
                <canvas id="nextPiece" class="next-piece" width="120" height="120"></canvas>
                
                <div class="score-panel">
                    <div class="score">分数: <span id="score">0</span></div>
                    <div class="level">等级: <span id="level">1</span></div>
                    <div class="lines">消除行数: <span id="lines">0</span></div>
                </div>
            </div>
            
            <div>
                <div class="controls">
                    <button id="startBtn">开始游戏</button>
                    <button id="pauseBtn">暂停</button>
                    <button id="resetBtn">重置</button>
                </div>
                
                <div class="controls-info">
                    <p>← → : 左右移动</p>
                    <p>↑ : 旋转</p>
                    <p>↓ : 加速下落</p>
                    <p>空格键 : 直接下落</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 获取canvas元素
        const gameBoard = document.getElementById('gameBoard');
        const nextPieceCanvas = document.getElementById('nextPiece');
        const ctx = gameBoard.getContext('2d');
        const nextCtx = nextPieceCanvas.getContext('2d');
        
        // 获取分数和按钮元素
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        // 游戏常量
        const ROWS = 20;
        const COLS = 12;
        const BLOCK_SIZE = 20;
        
        // 游戏变量
        let board = [];
        let currentPiece;
        let nextPiece;
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameInterval;
        let gameSpeed = 1000; // 初始速度，毫秒
        let isGameOver = false;
        let isPaused = false;
        
        // 方块定义
        const PIECES = [
            [
                [1, 1, 1, 1]  // I形
            ],
            [
                [1, 1, 1],    // T形
                [0, 1, 0]
            ],
            [
                [1, 1, 1],    // L形
                [1, 0, 0]
            ],
            [
                [1, 1, 1],    // J形
                [0, 0, 1]
            ],
            [
                [1, 1],       // O形
                [1, 1]
            ],
            [
                [0, 1, 1],    // S形
                [1, 1, 0]
            ],
            [
                [1, 1, 0],    // Z形
                [0, 1, 1]
            ]
        ];
        
        // 颜色定义
        const COLORS = [
            '#00BFFF', // 青色 - I
            '#9400D3', // 紫色 - T
            '#FF8C00', // 橙色 - L
            '#0000FF', // 蓝色 - J
            '#FFFF00', // 黄色 - O
            '#00FF00', // 绿色 - S
            '#FF0000'  // 红色 - Z
        ];
        
        // 初始化游戏
        function initGame() {
            // 创建空白游戏板
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            
            // 生成第一个方块和下一个方块
            currentPiece = generatePiece();
            nextPiece = generatePiece();
            
            // 重置分数
            score = 0;
            level = 1;
            lines = 0;
            gameSpeed = 1000;
            
            // 更新UI
            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesElement.textContent = lines;
            
            // 重置游戏状态
            isGameOver = false;
            isPaused = false;
            
            // 绘制初始状态
            drawBoard();
            drawPiece();
            drawNextPiece();
        }
        
        // 生成随机方块
        function generatePiece() {
            const pieceIdx = Math.floor(Math.random() * PIECES.length);
            const piece = PIECES[pieceIdx];
            const colorIdx = pieceIdx;
            
            // 中心放置在顶部
            const x = Math.floor((COLS - piece[0].length) / 2);
            const y = 0;
            
            return {
                shape: piece,
                color: COLORS[colorIdx],
                x: x,
                y: y
            };
        }
        
        // 绘制游戏板
        function drawBoard() {
            // 清除画布
            ctx.clearRect(0, 0, gameBoard.width, gameBoard.height);
            
            // 绘制已固定的方块
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        const colorIdx = board[y][x] - 1;
                        ctx.fillStyle = COLORS[colorIdx];
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.strokeStyle = '#FFF';
                        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                }
            }
            
            // 绘制网格
            ctx.strokeStyle = '#EEE';
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
        }
        
        // 绘制当前方块
        function drawPiece() {
            if (!currentPiece) return;
            
            ctx.fillStyle = currentPiece.color;
            
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        ctx.fillRect(
                            (currentPiece.x + x) * BLOCK_SIZE,
                            (currentPiece.y + y) * BLOCK_SIZE,
                            BLOCK_SIZE,
                            BLOCK_SIZE
                        );
                        ctx.strokeStyle = '#FFF';
                        ctx.strokeRect(
                            (currentPiece.x + x) * BLOCK_SIZE,
                            (currentPiece.y + y) * BLOCK_SIZE,
                            BLOCK_SIZE,
                            BLOCK_SIZE
                        );
                    }
                }
            }
        }
        
        // 绘制下一个方块
        function drawNextPiece() {
            // 清除画布
            nextCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
            
            if (!nextPiece) return;
            
            const blockSize = 20;
            const centerX = (nextPieceCanvas.width - nextPiece.shape[0].length * blockSize) / 2;
            const centerY = (nextPieceCanvas.height - nextPiece.shape.length * blockSize) / 2;
            
            nextCtx.fillStyle = nextPiece.color;
            
            for (let y = 0; y < nextPiece.shape.length; y++) {
                for (let x = 0; x < nextPiece.shape[y].length; x++) {
                    if (nextPiece.shape[y][x]) {
                        nextCtx.fillRect(
                            centerX + x * blockSize,
                            centerY + y * blockSize,
                            blockSize,
                            blockSize
                        );
                        nextCtx.strokeStyle = '#FFF';
                        nextCtx.strokeRect(
                            centerX + x * blockSize,
                            centerY + y * blockSize,
                            blockSize,
                            blockSize
                        );
                    }
                }
            }
        }
        
        // 检查碰撞
        function checkCollision(piece, offsetX, offsetY, newShape) {
            const shape = newShape || piece.shape;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        
                        if (
                            newX < 0 || 
                            newX >= COLS || 
                            newY >= ROWS || 
                            (newY >= 0 && board[newY][newX])
                        ) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 旋转方块
        function rotatePiece() {
            if (!currentPiece) return;
            
            // 创建新的旋转后的形状
            const newShape = [];
            for (let x = 0; x < currentPiece.shape[0].length; x++) {
                const row = [];
                for (let y = currentPiece.shape.length - 1; y >= 0; y--) {
                    row.push(currentPiece.shape[y][x]);
                }
                newShape.push(row);
            }
            
            // 检查旋转后是否会发生碰撞
            if (!checkCollision(currentPiece, 0, 0, newShape)) {
                currentPiece.shape = newShape;
            }
        }
        
        // 移动方块
        function movePiece(dx, dy) {
            if (!currentPiece || isPaused || isGameOver) return;
            
            // 检查是否会发生碰撞
            if (!checkCollision(currentPiece, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                drawBoard();
                drawPiece();
                return true;
            }
            
            // 如果是向下移动且发生碰撞，则固定方块
            if (dy > 0) {
                freezePiece();
                return false;
            }
            
            return false;
        }
        
        // 直接下落
        function dropPiece() {
            if (!currentPiece || isPaused || isGameOver) return;
            
            while (movePiece(0, 1)) {
                // 持续向下移动直到不能移动
            }
        }
        
        // 固定方块
        function freezePiece() {
            if (!currentPiece) return;
            
            // 将当前方块添加到游戏板上
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;
                        
                        // 如果方块超出顶部边界，游戏结束
                        if (boardY < 0) {
                            gameOver();
                            return;
                        }
                        
                        // 将方块颜色信息添加到游戏板
                        if (boardY >= 0) {
                            board[boardY][boardX] = PIECES.indexOf(PIECES.find(p => 
                                JSON.stringify(p) === JSON.stringify(currentPiece.shape)
                            )) + 1;
                        }
                    }
                }
            }
            
            // 检查是否有完整的行
            clearLines();
            
            // 生成新方块
            currentPiece = nextPiece;
            nextPiece = generatePiece();
            drawNextPiece();
            
            // 检查新方块是否立即碰撞（游戏结束条件）
            if (checkCollision(currentPiece, 0, 0)) {
                gameOver();
            }
        }
        
        // 清除完整的行
        function clearLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                // 检查当前行是否已满
                if (board[y].every(cell => cell !== 0)) {
                    // 移除当前行
                    board.splice(y, 1);
                    // 在顶部添加新的空行
                    board.unshift(Array(COLS).fill(0));
                    
                    // 行数+1，分数增加
                    linesCleared++;
                    
                    // 由于移除了一行，需要再次检查当前行
                    y++;
                }
            }
            
            if (linesCleared > 0) {
                // 计算分数
                switch (linesCleared) {
                    case 1:
                        score += 100 * level;
                        break;
                    case 2:
                        score += 300 * level;
                        break;
                    case 3:
                        score += 500 * level;
                        break;
                    case 4:
                        score += 800 * level;
                        break;
                }
                
                // 更新总行数
                lines += linesCleared;
                
                // 更新等级
                level = Math.floor(lines / 10) + 1;
                
                // 更新游戏速度
                gameSpeed = Math.max(100, 1000 - (level - 1) * 100);
                
                // 如果游戏正在运行，重新设置间隔
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = setInterval(update, gameSpeed);
                }
                
                // 更新UI
                scoreElement.textContent = score;
                levelElement.textContent = level;
                linesElement.textContent = lines;
            }
        }
        
        // 游戏更新
        function update() {
            if (isPaused || isGameOver) return;
            movePiece(0, 1);
        }
        
        // 游戏结束
        function gameOver() {
            clearInterval(gameInterval);
            gameInterval = null;
            isGameOver = true;
            
            // 绘制游戏结束信息
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, gameBoard.width, gameBoard.height);
            
            ctx.fillStyle = '#FFF';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('游戏结束!', gameBoard.width / 2, gameBoard.height / 2 - 30);
            ctx.fillText(`最终分数: ${score}`, gameBoard.width / 2, gameBoard.height / 2);
            ctx.fillText('点击重置开始新游戏', gameBoard.width / 2, gameBoard.height / 2 + 30);
            
            startBtn.textContent = '开始游戏';
        }
        
        // 开始游戏
        function startGame() {
            if (isGameOver) {
                resetGame();
                return;
            }
            
            if (!gameInterval) {
                isPaused = false;
                gameInterval = setInterval(update, gameSpeed);
                startBtn.textContent = '重新开始';
                pauseBtn.textContent = '暂停';
            } else {
                resetGame();
            }
        }
        
        // 暂停游戏
        function pauseGame() {
            if (isGameOver) return;
            
            if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = '暂停';
                if (!gameInterval) {
                    gameInterval = setInterval(update, gameSpeed);
                }
            } else {
                isPaused = true;
                pauseBtn.textContent = '继续';
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                    
                    // 绘制暂停信息
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, gameBoard.width, gameBoard.height);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('游戏暂停', gameBoard.width / 2, gameBoard.height / 2);
                }
            }
        }
        
        // 重置游戏
        function resetGame() {
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            
            initGame();
            drawBoard();
            drawPiece();
            
            startBtn.textContent = '开始游戏';
            pauseBtn.textContent = '暂停';
        }
        
        // 键盘控制
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            
            switch (e.keyCode) {
                case 37: // 左箭头
                    movePiece(-1, 0);
                    break;
                case 39: // 右箭头
                    movePiece(1, 0);
                    break;
                case 40: // 下箭头
                    movePiece(0, 1);
                    break;
                case 38: // 上箭头
                    rotatePiece();
                    drawBoard();
                    drawPiece();
                    break;
                case 32: // 空格键
                    dropPiece();
                    break;
                case 80: // P键
                    pauseGame();
                    break;
            }
        });
        
        // 按钮事件
        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', pauseGame);
        resetBtn.addEventListener('click', resetGame);
        
        // 初始化游戏
        initGame();
    </script>
</body>
</html> 